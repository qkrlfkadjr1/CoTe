"""
1. 내가 생각해낸 아이디어를 구현하기에 너무 복잡하였다.
2. 리스트를 입력받은 수치 n만큼 만들면 index error가 뜨고, n의 한계 수치인 1000까지 만들면 정답처리가 되었다.  파악이 아직 안됐다.

내 아이디어:

1부터 세다가, 공포도 문제처럼, 갯수 합이 해당 종류보다 커지는 시점에서 선택.
선택하면 정렬후 해당 종류 수까지 합의 최댓값 더해서 결과값에 +
지금까지 했던 인덱스들 다 지우고 처음부터 시작, 반복
만약에 초과하지 않으면 마지막에 남은 점수 다 합치기
인덱스를 지우진 말고, 비교 함수 i-count
반복

수를 받아서, 순서대로 처리한다.
만약에 같은 수가 있으면, 그 수까지 있는 수들 중 높은 애들 순으로 수행
[1,2,3,4,5,6,7,8,...,1000] 종류
[1,1,1,3,0,1,0,0,,,,] 갯수
for i in list:
	if list[i][개수인덱스]>1:
		for j in i:
			list2.append(list[j][과제점수인덱스])


다른 사람 알고리즘 참고:
과제 점수가 높은 순으로 먼저 나열 한 후,
최대한 과제 기한에 가까이 낸다.
예를 들어서 문제 예시 사항인
4 60
4 40
2 50
3 30
1 20
4 10
6 5 인 경우에,
60점짜리를 4일에 하고,
50점짜리를 2일에 한다.
40점짜리는 4일남았지만 4일에 이미 60점짜리가 예정되어 있으므로 3일에 한다.
30점짜리는 3일남았지만 3일에 이미 40점짜리가 예정되어 있으므로 1일에 한다.
20점짜리와 10점짜리는 1일 미만이 되므로 포기한다.
5점짜리는 6일에 한다.
따라서 185점이다.
위의 알고리즘을 따라 코딩을 해 보았지만, 결과는 잘 나오나 IndexError가 뜬다.


다른 사람의 코드의 도움을 받아 해결했다.
정답 코드와 내 코드의 차이점을 찾아보니,
점수를 저장하는 리스트인 result에 0을 n개 넣냐, 1000개 넣냐는 점이었다.
n을 넣으면 index error가 뜨고, 1000을 넣으면 정답이 뜬다.
왜일까?


"""

n=int(input())
data=[]
for i in range(n):
	data.append(list(map(int, input().split())))

data=sorted(data, key=lambda x: x[1])
data.reverse()
result=[0]*n
#1000을 n으로 바꾸면 런타임 에러가 뜬다. ide에서는 정상적으로 구동한다.

for i in range(n):
	a=data[i][1]
	while result[data[i][0]-1] != 0:
	
		data[i][0]-=1
		if data[i][0]<1:
			break
	if data[i][0]>0:
		result[data[i][0]-1] = a

sum=0
for i in result:
	sum+=i
print(sum)




