"""
처음 생각한 알고리즘은,
보석은 가장 비싼 순으로 나열하고, 가방은 가장 큰 순으로 나열한다.
그 후, 각 가방에 따라서 비싼보석부터 탐색한 후, 보석의 무게가 가방의 제한보다 낮으면 가방에 넣는다.
그 후, 그 다음 보석부터 연속해서 탐색해서 반복한다.

이 알고리즘에서 틀린 점은, 극단적인 예시로 첫번째 보석이 무게가 1, 가격이 100만이고 두번째 보석이 무게가 100만, 가격이 1, ... 이라고 해보자.
가방을 가장 큰 순으로 나열했을 때, 가방의 제한이 예를들어 100만, 10만, 1만, ... 으로 간다고 치면
내 알고리즘대로 시행했을 때 첫번째 가방은 가격이 100만인 보석을 담는다.
그러나, 두번째 가방은 가격이 1인 보석을 담을수 없다. 결국 총 가격은 100만이다.
하지만, 실제로는 첫번째 가방이 두번째 보석을 담고 두번째 가방은 첫번째 보석을 담을 수 있으므로 최대값은 100만1원이다.


이 문제를 해결하기 위해 heapq를 도입해본다고 가정하자.
heapq는 pop을 할 경우 가장 작은 값을 내놓는다.

이 문제를 푸는 알고리즘은, 용량이 작은 가방 순으로 정렬하였을 때,
현재 가방의 제한보다 가벼운 보석들 중 가장 비싼 보석을 뽑아내고, 이를 모든 가방에 대해 반복하는 것이다.
여기서 포인트는 "용량이 작은 가방부터" 보석을 담는 것이다.


우선순위큐 (heapq)를 사용하여 문제를 풀 수 있을 것 같지만, 다른 사람의 코드를 참고해보아도 도저히 이해가 되질 않아서,
다음에 마저 풀기로 하였다.
"""
