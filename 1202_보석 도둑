"""
21.09.07

bag의 개수만큼 보석을 담을 기회가 있다.
가장 작은 가방부터 시작해서, 가방 제한보다 가벼운 보석들을 모두 "힙"에 담는다. (자동 최소힙 정렬됨)
이 때, 힙에 담을 때는 보석 정보 info 힙에서 모두 "pop"한다.
가방 제한을 넘어서면 멈추고, 그 중에서 가장 큰 놈을 "가격만" push한다. (최대힙으로 구성하여야 함)

그 후, 다음 가방에 대해서 이어서 늘어난 제한 만큼 보석을 "힙"에 push한다.
이 전에 담아두고 남은 보석들과 새로 들어온 보석들은 모두 자동 최소힙 정렬되므로, 똑같이 가장 큰 놈을 "가격만" push한다.





이틀에 걸쳐 푼 문제, 다시 풀었을 때 혼자 힘으로 풀 수 있을지 모르겠음.
알고리즘은 가장 가벼운 가방부터 시작해서 그 안에 들어갈 수 있는 보석들 중 가장 비싼 보석을 넣는다.
그 다음 가방은 이전 가방에 들어갈 수 있던 보석은 당연히 이번에도 담을 수 있고, 추가적인 보석들에 대해서 그중에서도 가장 비싼 보석을 넣는다.
이를 반복한다.
이러한 과정을 시간 복잡도를 해결하면서 풀어나갈 수 있는 기법인 "힙"을 이용하는 것이다.
"""

import sys
import heapq

input=sys.stdin.readline
n,k=map(int, input().split())
gem_info=[]
for i in range(n):
	heapq.heappush(gem_info, (list(map(int, input().split()))))
bag=[]
for j in range(k):
	heapq.heappush(bag, int(input()))

able=[] #현재 가방 제한에 부합하는 보석들의 가격 힙
ans=0

for i in range(k):
	limit=heapq.heappop(bag) #현재 가방의 제한
	while len(gem_info)!=0 and limit>=gem_info[0][0]: #과정 중에 모든 보석이 이미 제한보다 가벼워 지는 경우를 대비함
		[weight, value]=heapq.heappop(gem_info)
		heapq.heappush(able, -value) #-를 붙이는 이유: 최대힙 구성을 위해
	if len(able)!=0: #더 담을 수 있는 보석이 없으면 다음 가방 제한으로 넘어가야 함
		ans-=heapq.heappop(able) #-를 하는 이유: 최대힙 구성을 위해
			
print(ans)



















"""
21.09.06

처음 생각한 알고리즘은,
보석은 가장 비싼 순으로 나열하고, 가방은 가장 큰 순으로 나열한다.
그 후, 각 가방에 따라서 비싼보석부터 탐색한 후, 보석의 무게가 가방의 제한보다 낮으면 가방에 넣는다.
그 후, 그 다음 보석부터 연속해서 탐색해서 반복한다.

이 알고리즘에서 틀린 점은, 극단적인 예시로 첫번째 보석이 무게가 1, 가격이 100만이고 두번째 보석이 무게가 100만, 가격이 1, ... 이라고 해보자.
가방을 가장 큰 순으로 나열했을 때, 가방의 제한이 예를들어 100만, 10만, 1만, ... 으로 간다고 치면
내 알고리즘대로 시행했을 때 첫번째 가방은 가격이 100만인 보석을 담는다.
그러나, 두번째 가방은 가격이 1인 보석을 담을수 없다. 결국 총 가격은 100만이다.
하지만, 실제로는 첫번째 가방이 두번째 보석을 담고 두번째 가방은 첫번째 보석을 담을 수 있으므로 최대값은 100만1원이다.


이 문제를 해결하기 위해 heapq를 도입해본다고 가정하자.
heapq는 pop을 할 경우 가장 작은 값을 내놓는다.

이 문제를 푸는 알고리즘은, 용량이 작은 가방 순으로 정렬하였을 때,
현재 가방의 제한보다 가벼운 보석들 중 가장 비싼 보석을 뽑아내고, 이를 모든 가방에 대해 반복하는 것이다.
여기서 포인트는 "용량이 작은 가방부터" 보석을 담는 것이다.


우선순위큐 (heapq)를 사용하여 문제를 풀 수 있을 것 같지만, 다른 사람의 코드를 참고해보아도 도저히 이해가 되질 않아서,
다음에 마저 풀기로 하였다.
"""

"""

"""
